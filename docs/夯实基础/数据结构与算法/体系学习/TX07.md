# day07

## 堆
### TX07_001 最大线段重合问题
> 给定很多线段，每个线段都有两个数[start,end]，表示线段开始位置和结束位置，左右都是闭区间   
> 规定：   
> 1、线段的开始和结束位置一定都是整数    
> 2、线段重合区域的长度>=1   
> 返回线段最多重合区域中，包含了几条线段   
> 
> 思路1：    
> 遍历所有的线段，找到左区间的最小值和右区间的最大值，所有线段都在这个区间[min,max]   
> 遍历从min到max中，所有的.5位置（只要不是刚好整数，都可以），看每个位置有多少个线段包含该位置，找到最大值就是答案   
> 因为
> 
> 思路2：   
> 使用小根堆    
> 首先将所有的线段根据左区间的值从小到大排序    
> 按照从小到大的顺序：小根堆中，<=当前线段左区间的数全部弹出，
> 然后右区间的数放进小根堆，此时小根堆中有几个数，就是当前线段的答案    
> 找出所有线段答案的最大值就是最终结果   

### TX07_002 加强堆（实现一个堆结构，支持isEmpty、size、contains、peek、pop、push、remove操作）
> 加一个反向索引表HashMap，记录每个元素在数组的哪个位置   
> heapSize记录堆使用到了数组的哪个位置    
> 
> 堆必须实现的方法：heapInsert和heapify    
> 
> 

### TX07_003 加强堆（模拟电商topk得奖）
> 题目：   
> 给定一个整型数组，int[] arr;和一个布尔类型数组，boolean[] op两个数组一定等长，假设长度为N，   
> arr[i]表示客户编号，op[i]表示客户操作。     
> arr = [3,3,1,2,1...]    
> op  = [T,T,T,T,F...]   
> 依次表示：   
> 3用户购买了一件商品；   
> 3用户购买了一件商品；  
> 1用户购买了一件商品；  
> 2用户购买了一件商品；  
> 1用户退货了一件商品；  
> 现在你作为电商平台的负责人，你想在每个事件到来的时候，都给购买次数最多的k名用户颁奖。    
> 所以每个事件发生后，你都需要一个获奖名单
> 
> 得奖规则：    
> 1.如果某个用户购买商品数为0，但是又发生了退货事件，则认为该事件无效，得奖名单和之前事件时一致    
> 2.某用户发生购买事件，购买商品数+1，发生退货事件，购买商品数-1   
> 3.每次都是最多k个用户获奖，k也为传入的参数    
> 4.得奖系统分为得奖去和候选区，任何用户只要购买数>0，一定在这两个区域中的一个    
> 5.购买数最大的前k名用户进入得奖区，在最初如果得奖区没有达到k个用户时，那么新来的用户直接进入得奖区    
> 6.如果购买数不足以进入得奖区，进入候选区   
> 7.如果候选区购买数最多的用户，已经足以进入得奖区，   
> 该用户就会替换得奖去中购买数最少的用户(大于才能替换)     
> 如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户    
> 如果候选区中购买数最多的用户有多个，机会会给最早进入候选区的用户     
> 8.候选区和得奖区是两套时间   
> 因用户只会在其中一个区域，所以只会有一个区域的时间，另一个没有     
> 从得奖区出来进入候选区的用户，得奖区时间删除    
> 进入候选区的时间就是当前时间的时间（可以理解为arr[i]和op[i]中的i就是时间）     
> 从候选区出来进入得奖区的用户，候选区时间删除    
> 进入得奖区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i就是时间）     
> 9.如果某用户购买数==0，不管在哪个区域都离开    
> 如果下次该用户又发生购买行为，产生>0的购买数，会再次根据之前规则回到某个区域中，进入区域的时间重记   
> 如果根据规则，得奖人数不够k个，按实际情况输出    
