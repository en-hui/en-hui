# 排序

## 排序算法总结
1.不基于比较的排序，对样本数据有严格要求，不易改写   
2.基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用   
3.基于比较的排序，时间复杂度的极限是O(N*log(N))   
4.时间复杂度O(N*log(N))、额外空间复杂度低于O(N)、且稳定的基于比较的排序不存在   
5.为了绝对的速度选快排，为了省空间选堆排序，为了稳定性选归并排序   
![Alt](../img/排序总结.png)

## 基于比较的排序

### 选择排序
### 冒泡排序
### 插入排序
### 归并排序
### 快速排序
### 堆排序

## 不基于比较的排序——桶排序
桶排序思想下的排序： 计数排序 & 基数排序
> 桶排序思想下的排序都是不基于比较的排序   
> 时间复杂度O(N) , 额外空间复杂度 O(M)   
> 应用范围有限，需要样本的数据状况满足桶的划分

### 计数排序
计数排序（桶排序的一种，相当于用一个数字做桶）  
要求样本是整数，而且范围比较窄
> 例子：一个数组中arr[] 存了N个员工的年龄，将数组排序   
> 员工年龄肯定不大于200岁，所以我创建一个help[201]，0位置表示0岁，201位置表示200岁   
> 遍历原数组，向help数组中写数，将对应位置 值++    
> 遍历help数组，对原数组进行覆盖。   
> 排序完成，时间复杂度 O(N)

### 基数排序
基数排序（桶排序的一种，相当于用一个队列做桶）   
经典的基数排序用骚操作,用数组模拟队列入栈出栈过程   
要求样本是10进制的正整数
> 例子：一个数组[100,5,13,27,17,29,19] 进行排序    
> 所有数字以位数最多的为准，补足位置，前面补0    
> 做一个0~9的数组，数组上挂着一个队列做桶     
> 以个位数字比较，放进对应桶中，放完之后在从0号桶开始倒回原数组   
> 然后以十位数字比较，放进对应桶中，放完之后从0号桶开始在倒回原数组   
> 以此类推比较到最高位，最后一次放回原数组时，有序了
>
> 经典实现思路：   
![Alt](../img/基数排序的逻辑.png)
