# day06

## 堆
> 完全二叉树的定义：从上到下都是满的二叉树，即使最下面一层不是满的，也在从左到右变满的路上    
> 堆结构就是完全二叉树结构   
> 堆分为**大根堆**和**小根堆**   
> 大根堆的定义：完全二叉树中如果每棵子树的最大值都在顶部就是大根堆   
> 小根堆的定义：完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
>
> 用数组做完全二叉树结构：    
> 1.从数组0开始   
> 当前节点下标为i，则左孩子节点下标为2*i+1;右孩子节点下标为2*i+2;父节点下标为(i-1)/2     
> 2.从数组1开始，0位置不用.这样做可以最大程度使用位运算    
> 当前节点下标为i，则左孩子节点下标为2*i，右孩子节点下标为2*i+1，父节点为i/2

### 用数组实现大根堆，支持 offer(heapInsert) 和 poll(heapify)
> 堆结构的 heapInsert 和 heapify 操作    
> **heapInsert** 上浮操作，例如大根堆   
> 向大根堆添加数据a时，数据a放在最后一个位置，调整他的位置直到恢复大根堆结构    
> 将a与父节点比较，如果a大于父节点，就要交换，直到不大于父节点为止
>
> **heapify** 下沉操作，例如大根堆   
> 获取大根堆中的最大值，用大根堆的顶与最后一个位置的数a交换，并把最后一个位置从大根堆中去掉    
> 调整顶上数a的位置直到恢复大根堆    
> 当a比他的左右子节点小时，要将左右子节点中较大的数与a交换，直到a不大于子节点的数为止

### 堆排序
> 排序数组0～N-1位置上的数    
> 将0～N-1的数调整为大根堆，0位置的数是最大值，与N-1交换    
> 将0～N-2的数调整为大根堆，0位置的数是最大值，与N-2交换    
> 一直到0～0 整个数组都变有序了    

### 已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对数组长度是比较小的。选择一个合适的排序策略对数组排序   
> 分析：    
> 看从0～k位置上，最小值一定在0～k位置，0位置排好后，    
> 看从1～k+1位置上，最小值一定在1～k+1位置上    
> 利用小根堆，依次将0～k位置数放进去，弹出最小值，放在0位置，然后放数组k+1的数   
> 弹出最小值，放在i位置，在放下一个位置的数    
> 当数组中没有数可以放的时候，依次弹出剩余的数即可