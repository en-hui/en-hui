# day04

## 归并

### 归并排序

> 递归实现归并排序    
> 0到N-1位置进行递归    
> 左边有序=0～N/2 递归    
> 右边有序=N/2+1~N-1 递归   
> 全部有序=左边 merge 右边
>
> 非递归实现归并排序    
> 设置步长，分别为1，2，4，8...    
> 左步长与右步长进行merge，一直到数组最后   
> 比如: 1 3 8 4 9 2    
> 步长为1进行merge：1 3；4 8；2 9     
> 步长为2进行merge：1 3 4 8；2 9    
> 步长为4进行merge：1 2 3 4 8 9

### 小和问题，一个数组，计算每个位置左边比他小的数据的和，要求O(N * logN)

> 小和的定义    
> 有一个数组：[6 3 2 1 6 7]      
> 每个位置，比他小的数据的和是[0 0 0 0 6 18]    
> 最终结果为：24    
> 思路：   
> 0位置时-6，左边没有比他小的    
> 1位置时-3，左边没有比他小的    
> 2位置时-2，左边没有比他小的    
> 3位置时-1，左边没有比他小的    
> 4位置时-6，左边比他小的：1个3，1个2，1个1    
> 5位置时-7，左边比他小的：1个6，1个3，1个2，1个1，1个6    
> 
> 换个视角看，只要知道我的右边有几个数比我大，我就可以用 我*n 来得到关于我的小和    
> 所以可以借用归并排序的过程，在过程中添加一些步骤来计算得到小和    
> 步骤：      
> merge时，左边比右边大，直接放右边，不产生小和     
> 左边和右边相等，放右边的数，不产生小和    
> 左边比右边小，左边数为num，看右边有n个比左边大（因为有序，所以不用遍历），产生n * num

### 数组中有多少个逆序对，逆序对：任意两个数据（不用相邻），右边比左边小
> 和小和问题类似   
> merge时，每侧都从右往左遍历，两边数相等时先放右侧的数   
> 放的时候，也是从右往左放，排好序还是从小到大    
> 4, 5, 2, 3   
> 假设上面走到最后一步，左边两个有序，右边两个有序    
> 4, 5 --- 2, 3     
> 左边5，右边3，右边小，左边大，那右侧从3往左的个数都比5小，有2个，5放临时数组的最后，左侧想左看         
> 左边4，右边3，右边小，左边大，那右侧从2往左的个数都比4小，有2个，4放临时数组的最后，左侧没了   
> 得到结果是4   
>  
> 技巧：为什么这个题要从右往左呢？因为局部有序，左下右大，假如右侧的比左侧的小，那右侧剩余部分都比左侧这个数小   

### num右边有多少个数，乘以2依然比num小，求整个数组中每个数的这种个数的总和
> 先找个数，然后在merge数组    
> 左侧没移动一位，右侧都从最左侧尝试往右滑动寻找，一直找不到为止      
> 3, 7, 2, 9   
> merge    
> 左边3，右边2，2乘以2大于3，所以没有    
> 左边7，右边2，2乘以2小于7，右侧往后看，2乘以9大于7，所有有1个    