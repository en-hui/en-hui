# 算法第三天学习

## 归并排序
> 将数组分为左右两边，利用递归将问题最小化，即左边和右边指向同一位置时。   
将左右两边进行merge，即申请一个同长度数组，比较左右两边，谁小先放谁，直至数组整个有序   
可以应用在所有纠结左边有多少个数比自己大等类似问题   

```
1.归并排序
Code01_MergeSort

2.求小和问题
小和：一个数组中，所有左侧比自己小的数加起来称为小和
Code02_SmallSum

3.找出数组中有多少个降序对
降序对：一个数组中，所有向右看比当前数小的数，都可以组成降序对
Code03_DescPair
```

## 快速排序
> 


```
1.Partition 过程
问题：给定一个数组arr，和一个整数num。把小于等于num的数放在数组的左边，大于num的数放数组的右边。
要求额外空间复杂度O(1),时间复杂度O(N)
思路：定义一个 index 指向-1位置
数组遍历与num比较
如果数组中的数小于等于num，将这个数与 index+1位置的数交换，index后移，数组下标也后移
如果数组中的数大于num，直接后移
Code04_Partition

2.三色旗（荷兰旗）排序算法
问题：给定一个数组arr，和一个整数num。把小于num的数放在数组的左边，等于num的数放数组的中间，大于num的数放数组的右边
思路：定义两个下标，小于区域 minIndex=-1 大于区域 maxIndex=arr.length
数组遍历与num比较
如果数组中的数等于num，数组下标后移
如果数组中的数小于num，将这个数与 minIndex+1 位置交换， minIndex 后移，数组下标也后移
如果数组中的数大于num，将这个数与 maxIndex-1 位置交换， maxIndex 前移，数组下标不动
Code05_NetherLandsFlag

3.快速排序
经典快排：
从数组中随机取一个数与arr[R]交换
用荷兰旗+递归 
将所有 小于 arr[R]的数放左边
将所有 等于 arr[R]的数放中间
将所有 大于 arr[R]的数放右边
此排序算法 时间复杂度 --> O(N*log(N)) 额外空间复杂度 --> O(log(N))
```
