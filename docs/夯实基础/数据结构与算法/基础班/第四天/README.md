# 算法第四天学习

## 堆结构
> 完全二叉树的定义：从上到下都是满的二叉树，即使最下面一层不是满的，也在从左到右变满的路上    
> 堆结构就是完全二叉树结构   
> 堆分为**大根堆**和**小根堆**   
> 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆   
> 完全二叉树中如果每棵子树的最小值都在顶部就是小根堆  
> 
> 堆结构的 heapInsert 和 heapify 操作    
> **heapInsert** 上浮操作，例如大根堆，当添加一个数a在数组结尾时，要维持大根堆结构，就要将a与父节点比较，如果a大于父节点，就要交换，直到不大于父节点为止   
> **heapify** 下沉操作，例如大根堆，当一个位置的数a比他的左右子节点小时，要将左右子节点中较大的数与a交换，直到a不大于子节点的数为止    

用数组做完全二叉树结构：    
1.从数组0开始   
当前节点下标为i，则左孩子节点下标为2*i+1;右孩子节点下标为2*i+2;父节点下标为(i-1)/2     
2.从数组1开始，0位置不用.这样做可以最大程度使用位运算    
当前节点下标为i，则左孩子节点下标为2*i，右孩子节点下标为2*i+1，父节点为i/2

```
java中的小根堆：PriorityQueue
1.维持一个大根堆，支持添加元素操作，和取出并删掉最大值操作
思路：
添加元素功能：维护一个index，表示堆中数据的数量，每次添加元素，将元素放在index位置，并向父节点看，如果比父节点大就交换位置，循环往复
删除最大值功能：要返回的值为0位置的数，先把0位置的数记录一下，0位置与heapSize位置交换，heapSize-1，然后0位置一直与左右子节点最大值交换
Code02_Heap01

2.对已维持好数据的堆，当数据修改后，依然能维持堆结构，并且时间复杂度是O(N)
思路：维持一个indexMap，每次修改后对这个位置进行调整，避免了所有节点调整位置
Code03_Heap02

3.堆排序
1)先让整个数组变成大根堆，建立堆的过程：有两种
从上到下的方法，时间复杂度为O(N*log(N))
从下到上的方法，时间复杂度为O(N)
2)把堆的最大值与堆末尾的数交换，然后减少堆的大小之后，再去调整堆-->一直把最大的放在最后，直到有序。时间复杂度为O(N*log(N))
3)堆的大小减小到0时，排序完成
Code04_HeapSort

4.与堆相关的题目：
已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度N来说是比较小的
请选择一个合适的排序策略，对这个数组进行排序
思路：先把 0~k位置的数放进小根堆，把小根堆的头弹出放0位置，然后继续往小根堆放数
Code05_SortArrayMoveLessK
```


## 比较器
> 即java中的 Comparator 接口   
> 重写 compare(T t1,T t2)--> 返回负数表示 t1<t2,返回0表示t1=t2，返回正数表示t1>t2
