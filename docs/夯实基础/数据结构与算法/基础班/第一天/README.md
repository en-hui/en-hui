# 算法第一天学习

## 评估算法的核心指标
> 何为一个问题的最优解：   
> 时间复杂度一定要尽可能低，满足时间复杂度最低之后，
> 使用最少的额外空间的算法，就可以称为最优解

1. 时间复杂度
2. 额外空间复杂度
3. 常数项时间操作

> 常见的常数项时间操作：   
> 常见的算术运算符（+、-、*、/、%等）    
> 常见的位运算（>>、>>>、<<、&、|、^等）   
> 赋值、比较、自增、自减等   
> 数组寻址操作

## 时间复杂度为O(n<sup>2</sup>)的排序算法   
```
以下为思路，最好画图解析后在编码
1.选择排序：
0~N-1位置找最小值的位置与0位置交换
1~N-1位置找最小值的位置与1位置交换
...
N-2~N-1位置找最小值的位置与N-2位置交换
排序结束。编码见 Code01_SelectionSort

2.冒泡排序：
0~N-1位置，两两比较，大的后移，把最大放在N-1位置
0~N-2位置，两两比较，大的后移，把最大放在N-2位置
...
0~1位置，两两比较，大的后移，把最大值放在1位置
排序结束。编码见 Code02_BubbleSort

3.插入排序：例子（小->大排序）：2 1 3 4 5 6
0~0位置保证有效，从0向左看，没数了直接停
0~1位置保证有序，从1向左看，1位置比0位置小，交换，再看没数了停
0~2位置保证有序，从2向左看，2位置不比1位置小，直接停
...
0~N-1位置保证有序，N-1位置向左看，一直看到停为止
排序结束。编码见 Code03_InsertSort
```

## 二分法
```
1.在有序数组中找一个数字是否存在。
编码见 Code04_BSExist

2.在有序数组中，找到>=某数字的最左位置。
编码见 Code05_BSNearLeft

3.在有序数组中，找到<=某数字的最右位置。
编码见 Code06_BSNearRight

4.在无序数组中，找到局部最小位置(无序数组中任意相邻两个数都不相等)
局部最小定义：
如果0位置比1位置小。则0位置算一个局部最小位置
如果N-1位置比N-2位置小，则N位置算一个局部最小位置
如果Mid位置比Mid-1位置小，比Mid+1位置也小，则Mid位置算一个局部最小位置
编码见 Code07_BSAwesome
```

## 异或运算
简单记，异或运算就是无进位相加。   
异或运算的性质：  
> 1.``` 0^N=N  N^N=0 ```   
> 2.异或运算支持交换律和结合律  
> 把一个int类型的数N，提取最右侧1： N & (~N + 1)
 
```
1.不用中间变量，交换两个值（了解即可，两个值的内存地址相同不可以用）
a=a^b;
b=a^b;
a=a^b; 

2.一个数组中有一个数字出现了奇数次，其他数都出现了偶数次，怎么找到并打印这个数？
编码见 Code08_EventTimesOddTimes.printOddTimesNum1

3.一个数组中有两个数字出现了奇数次a和b，其他数都出现了偶数次，怎么找到并打印这两个数？
思路：
eor = 数组中所有数字异或 --> 本质是 a^b
rightOne = eor & (~eor + 1) -->找到 eor 最右侧的1
arr[i] & rightOne != 0 --> 可以筛选出所有N位置为1的数。这些数异或起来就是a
b = eor ^ a
编码见 Code08_EventTimesOddTimes.printOddTimesNum2
``` 