# 科普

## 所谓常识-磁盘与内存比较
**磁盘与内存** 

> 磁盘性能：    
> 1.寻址：毫秒级（ms）    
> 2.带宽：G或M
> 
> 内存性能：   
> 1.寻址：纳秒（ns）   
> 2.带宽：很大   
> 
> 1秒-1,000毫秒-1,000,000微妙-1,000,000,000纳秒    
> 也就是说，磁盘比内存在寻址上慢了**10w倍**-（非计算错误）


**IO Buffer**   

> 磁盘与磁道由扇区组成，一扇区为512字节，扇区过小，带来一个很大的成本问题：索引   
> 引入一种手段减少成本：格式化磁盘时，**4K对齐**，也就是无论你读多少内容，操作系统最少从磁盘拿4kb数据返给你。   
> 
> 以4k为单位建立索引，索引会变少很多   
> （一个512GB的磁盘，以512字节为单位，需要很多索引，但以4kb为单位，索引会减少很多）   


## 两个极端（完全基于磁盘和完全基于内存）
**首先我们要知道，数据在磁盘和内存中的体积是不一样的（内存中会有引用，实际占用会小于在磁盘中的占用）**

- 基于磁盘的关系型数据库（例如MySQL）   
> 数据存储由一个一个4k的data page组成，
> 
> 在无索引的情况下，检索即全表扫描，需要把所有的data page加载到内存中查找
> 
> 索引，也是存储在磁盘上的一个一个的data page    
> 准备一个B+树，会把树干加载到内存中（区间和偏移），叶子还在磁盘    
> 检索时where命中索引，会先检索索引文件，把叶子节点加载到内存，找到后再将数据加载到内存    
> 
> 海量数据时（数据量特别大，性能会下降？）    
> 1.增删改：   
> 1.1 如果表有索引，增删改会变慢（维护索引文件成本比较大，要调整树的结构）     
> 2.查询：   
> 2.1   1个或少量查询，且命中索引，速度很快（走索引，数据量大小影响较小）   
> 2.2   很多查询，即使都命中索引，速度也会变慢（性能受寻址和带宽两个因素影响，查询多，返回数据多，带宽也是瓶颈）   


- 基于内存的关系型数据库（SAP公司的HANA）   

基于两个常识可以知道，这种很好，价格也很好（极贵）

## 折中方案--缓存的引出   

> 2个基础设施   
> 1.冯诺依曼体系的硬件（制约）   
> 2.以太网，tcp/ip的网络（潜台词就是不稳定）   
> 
> 引出后续一系列问题：数据一致性、双写等


**缓存组件(k-v)的选择**    
> Memcached 和 Redis    
> 
> 首先来看下数据类型的几种表现形式：
> {name=hu,age=1}    
> [1,2,3,3]    
> [{},{}]    
> 
> Memcached 没有类型的概念，**k和v都是字符串类型**,但是v使用json，可以存储任何数据   
> 
> Redis 有类型的概念，**k是字符串类型，v有五种类型**   
> strings-包含字符串、数值、bitmaps   
> lists-本质就是双向链表     
> sets-没有重复元素的无序集合    
> sorted sets-没有重复，且使用权重保证顺序      
> hashes-键值对，适合存储对象   
> 
> 类型不是选择Redis的原因，因为使用json可以描述任何类型的数据   
> 重要的是Redis提供了基于类型的内置方法    
> 比如现在有一个需求    
> 缓存中存储了一个数组，里面有100个元素，现在想取出第十个元素   
> 使用Memcached：根据k获取100个元素，将数据拉回客户端，在代码中解析json数据，取出第十个元素   
> 使用Redis：根据k和元素下标，找到第十个元素，只把第十个元素拉回客户端   
> 全量拉回，会造成无用的数据拉取，给缓存服务器的网卡造成多余的压力（所以计算向数据移动更优）   